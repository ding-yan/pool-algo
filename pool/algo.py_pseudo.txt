

DEFINE FUNCTION contact_pos(tpos, hpos):

    """Return contact position of the target ball."""

    SET diff TO hpos - tpos

    IF diff[0,0] != 0:

        SET theta TO math.atan(abs(diff[1,0] / diff[0,0]))

    ELSE:

        SET theta TO math.pi / 2

    SET x_coef TO -1 IF diff[0,0] > 0 else 1

    SET y_coef TO -1 IF diff[1,0] > 0 else 1

    SET x TO tpos[0,0] + x_coef*2*config.radius*math.cos(theta)

    SET y TO tpos[1,0] + y_coef*2*config.radius*math.sin(theta)

    SET contact_pos TO np.matrix([[x], [y]])

    RETURN contact_pos



DEFINE FUNCTION mirror_transformation(pos:np.matrix, index_rr:np.matrix=None, index_ij:np.matrix=None, inverse=False):

    """Return mirror transformation of INPUT position with (i,j) and (r,r)."""

    SET x_reflect TO np.matrix([[1, 0], [0, -1]])

    SET y_reflect TO np.matrix([[-1, 0], [0, 1]])



    IF inverse:

        SET i TO floor((pos[0,0] / config.length))

        SET j TO floor((pos[1,0] / config.width))

        SET index_ij TO np.matrix([[i], [j]]) + index_rr



    SET index_diff TO index_ij - index_rr

    SET cx TO abs(index_diff[1,0] % 2)

    SET cy TO abs(index_diff[0,0] % 2)

    

    IF cx:

        SET index_diff TO index_diff + np.matrix([[0], [1]])

    IF cy:

        SET index_diff TO index_diff + np.matrix([[1], [0]])

    

    IF (inverse EQUALS False):

        SET comp_mat TO x_reflect ** cx * y_reflect ** cy

        RETURN comp_mat * pos + config.conf * index_diff

    ELSE:

        SET comp_mat TO y_reflect ** (-cy) * x_reflect ** (-cx)

        RETURN comp_mat * (pos - config.conf * index_diff)

    



DEFINE FUNCTION multiples_between_interval(start, end, multiple):

    """Return list of multiples between given interval."""

    SET mx TO max(start, end)

    SET mn TO min(start, end)

    SET mn TO ceil(mn/multiple) * multiple

    SET mx TO ceil(mx/multiple) * multiple

    RETURN list(range(mn, mx, multiple))



DEFINE FUNCTION point_between_two_points(x, p1, p2, inverse=False):

    """Return (x,y) with given x or y that on a line between two points."""

    SET slope TO (p2[1,0]-p1[1,0]) / (p2[0,0]-p1[0,0])

    IF not inverse:

        RETURN np.matrix([[x], [slope * (x-p1[0,0]) + p1[1,0]]])

    ELSE:

        RETURN np.matrix([[(x-p1[1,0]) / slope + p1[0,0]], [x]])



DEFINE FUNCTION angle_between_two_vectors(p1, p2):

    """Return angle between two vectors by dot computing."""

    RETURN math.acos(dot(p1, p2) / (norm(p1) * norm(p2)))



DEFINE FUNCTION distance_from_point_to_segment(p, p1, p2):

    """Return distance from point to segment by projection computing."""

    SET ab_vect TO p2 - p1

    SET ap_vect TO p - p1

    SET ac_proj_vect TO dot(ap_vect, ab_vect) * ab_vect / (norm(ab_vect) ** 2)

    SET r TO dot(ab_vect, ap_vect) / (norm(ab_vect) ** 2)

    IF r <= 0:

        RETURN norm(ap_vect)

    ELSEIF r >= 1:

        SET bp_vect TO p - p2

        RETURN norm(bp_vect)

    ELSE:

        SET cp_vect TO ap_vect - ac_proj_vect

        RETURN norm(cp_vect)



DEFINE FUNCTION distance_from_point_to_line(p, p1, p2):

    """Return distance from point to line by mathematic formula."""

    SET slope TO (p2[1,0]-p1[1,0]) / (p2[0,0]-p1[0,0])

    SET b TO -slope * p1[0,0] + p1[1,0]

    SET x, y TO p[0,0], p[1,0]

    RETURN abs((slope * x - y + b) / ((slope ** 2 + 1) ** (1/2)))



DEFINE FUNCTION norm(p):

    """Return norm of point."""

    RETURN (p[0,0] ** 2 + p[1,0] ** 2) ** (1/2)



DEFINE FUNCTION dot(p1, p2):

    """Return dot product with p1, p2."""

    RETURN (p1.T * p2)[0,0]

